{"version":3,"sources":["lib/object.js","lib/storage.js","lib/timer.js","App.js","serviceWorkerRegistration.js","reportWebVitals.js","index.js"],"names":["patch","obj","newObj","Object","assign","loadObject","key","string","window","localStorage","getItem","load","JSON","parse","saveObject","setItem","save","length","stringify","serialize","init","direction","duration","stateSnapshot","threshold","eventsSnapshot","laps","state","events","setState","newState","setLaps","newLaps","resolveLaps","lapTimestamps","map","time","startTime","filter","type","val","getEvents","getState","getLaps","_getEllapsedTime","includes","reduce","accum","index","arr","timestamp","prevTimestamp","prevType","running","paused","Date","now","getEllapsedTime","ellapsedTime","getEllapsedTimeString","parseSegment","padLength","str","padStart","pad","Math","abs","join","command","callback","push","start","pause","resume","stop","endTime","lap","clear","timerConfig","countdownTimer","timer","App","useState","setEllapsedTime","useEffect","appState","console","log","unloadListener","bind","addEventListener","removeEventListener","reqId","requestAnimationFrame","step","cancelAnimationFrame","className","lapData","onMouseDown","Boolean","location","hostname","match","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.3a425cdf.chunk.js","sourcesContent":["\r\n// mutates obj!\r\nexport const patch = (obj = {}, newObj = {}) => Object.assign(obj, newObj)\r\n\r\nexport const serialize = (...args) => args.length ? JSON.stringify(...args) : ''\r\n\r\nexport const deserialize = string => JSON.parse(string ?? '{}')\r\n","import {serialize, deserialize} from './object'\r\n\r\n\r\nconst load = key => window.localStorage && window.localStorage.getItem(key)\r\n\r\nconst save = (key, obj) => window.localStorage && window.localStorage.setItem(key, obj)\r\n\r\n\r\nexport const loadObject = key => deserialize(load(key))\r\n\r\nexport const saveObject = (key, obj) => save(key, serialize(obj))\r\n","import {patch} from './object'\r\n\r\n// the result of: new Date(1970, 0, 1).getTime()\r\nconst EPOCH = -7200000\r\n\r\n// todo - optionally accept a storage object with known crud api, and compse it\r\nconst init = ({\r\n  direction = 'up',\r\n  duration = 30 * 1000,\r\n  threshold = 10 * 1000,\r\n} = {}, stateSnapshot = {}, eventsSnapshot) => {\r\n\r\n  let laps = []\r\n  let state = stateSnapshot ?? {}\r\n\r\n  // {\r\n  //   type: 'play|stop|pause|resume|lap',\r\n  //   timestamp: 210010010010000,\r\n  // }\r\n  let events = eventsSnapshot ?? []\r\n\r\n  const setState = newState => patch(state, newState)\r\n  const setLaps = newLaps => patch(laps, newLaps)\r\n\r\n  const resolveLaps = (state, lapTimestamps) =>\r\n  (lapTimestamps || [])\r\n  .map(time => time - state.startTime)\r\n  // todo - use reduce to compare prev time and curr time, and add that as 'duration'\r\n\r\n  // ----------------------------------------------------------------\r\n  // todo - extract method (see below) and continue from there\r\n  .filter(({type}) => type === 'lap')\r\n  .map(val => val)\r\n\r\n\r\n  const getEvents = () => events\r\n  const getState = () => state\r\n  const getLaps = () => resolveLaps(state, events)\r\n\r\n  const _getEllapsedTime = () => events\r\n  // todo - extract some of this to a utilty that transforms the absolute data (global timestamps) to relative data (the timer period sums), then share with resolveLaps()\r\n  .filter(({type}) => ['start', 'stop', 'pause', 'resume'].includes(type))\r\n  .reduce((accum, {timestamp, type}, index, arr) => {\r\n    const {timestamp: prevTimestamp, type: prevType} = arr[index - 1] ?? {}\r\n    if (state.running && !state.paused && !arr[index + 1]) {\r\n      accum += Date.now() - timestamp\r\n    } else if ((type === 'pause' || type === 'stop') &&\r\n    (prevType === 'start' || prevType === 'resume')) {\r\n      accum += (timestamp - prevTimestamp)\r\n    }\r\n    return accum\r\n  }, 0)\r\n\r\n  const getEllapsedTime = (ellapsedTime = _getEllapsedTime()) => direction === 'up' ? ellapsedTime : duration - ellapsedTime\r\n\r\n  const getEllapsedTimeString = () => {\r\n    const time = getEllapsedTime()\r\n    const pad = (str, length = 2) => `${str}`.padStart(length, '0')\r\n    const parseSegment = (timestamp, padLength) => pad(Math.abs(Math[time < 0 ? 'ceil' : 'floor'](timestamp)), padLength)\r\n    return `${time < 0 ? '-' : ' '}${[\r\n      parseSegment(time / 1000 / 60 / 60),\r\n      parseSegment(time / 1000 / 60),\r\n      parseSegment(time / 1000),\r\n      parseSegment(time % 1000, 3),\r\n    ].join(':')}`\r\n  }\r\n\r\n  const command = (type, callback) => (time = Date.now()) => callback(time) && events.push({\r\n    type,\r\n    timestamp: time,\r\n  })\r\n\r\n  const start = command('start',\r\n  time => !state.running && setState({running: true, startTime: time}))\r\n  const pause = command('pause',\r\n  () => state.running && !state.paused && setState({paused: true}))\r\n  const resume = command('resume',\r\n  () => state.running && state.paused && setState({paused: false}))\r\n  const stop = command('stop',\r\n  time => state.running && setState({endTime: time, running: false}))\r\n  const lap = command('lap',\r\n  time => state.running && !state.paused && setLaps([...laps, time]))\r\n  const clear = () => !state.running && (state = {}) && (events = [])\r\n\r\n  return {\r\n    start,\r\n    pause,\r\n    resume,\r\n    stop,\r\n    lap,\r\n    clear,\r\n    getState,\r\n    getLaps,\r\n    getEvents,\r\n    getEllapsedTime,\r\n    getEllapsedTimeString,\r\n  }\r\n\r\n}\r\n\r\nexport default init\r\n","import React, {useState, useEffect} from 'react';\n// import logo from './logo.svg';\nimport {loadObject, saveObject} from './lib/storage'\nimport {serialize} from './lib/object'\nimport timer from './lib/timer'\nimport './App.css';\n\nconst timerConfig = {\n  direction: 'down',\n}\nlet countdownTimer = timer(timerConfig)\n\nfunction App() {\n\n  const [ellapsedTime, setEllapsedTime] = useState(countdownTimer.getEllapsedTimeString())\n  const [state, setState] = useState(countdownTimer.getState())\n  const [laps, setLaps] = useState(countdownTimer.getLaps())\n\n  useEffect(() => {\n    // load application state from storage, in case the tab was closed/refreshed\n    const appState = loadObject('countdown-state')\n    setState(appState.state)\n    setLaps(appState.laps)\n    countdownTimer = timer(timerConfig, appState.state, appState.events)\n    console.log('countdownTimer', countdownTimer)\n  }, [])\n\n  useEffect(() => {\n    // when the tab is closed/refreshed, save application state to storage\n    const unloadListener = saveObject.bind(null, 'countdown-state', {\n      state: countdownTimer.getState(),\n      events: countdownTimer.getEvents(),\n      laps: countdownTimer.getLaps(),\n    })\n    window.addEventListener('beforeunload', unloadListener)\n    return () => {\n      window.removeEventListener('beforeunload', unloadListener)\n    }\n  }, [])\n\n  useEffect(() => {\n    let reqId = window.requestAnimationFrame(function step() {\n      setEllapsedTime(countdownTimer.getEllapsedTimeString())\n      if (state.running && !state.paused) {\n        reqId = window.requestAnimationFrame(step)\n      }\n    })\n    return () => {\n      window.cancelAnimationFrame(reqId)\n    }\n  }, [state])\n\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n        <h1 className=\"App-title\">countdown</h1>\n      </header>\n      <main className=\"App-main\">\n        <code>\n          {(countdownTimer.getLaps() || []).map(lapData => <p>{lapData}</p>)}\n        </code>\n        <pre className=\"App-time-counter\">\n          {ellapsedTime}\n        </pre>\n        <nav className=\"App-controls\">\n\n          {/* todo - bind keyboard events */}\n          {/* todo - don't setState, do it more selectively. what do we really need here? */}\n          <button className={`App-button-${state.running ? state.paused ? 'resume' : 'pause' : 'start'}`} onMouseDown={() => countdownTimer[state.running ? state.paused ? 'resume' : 'pause' : 'start']() && setState({...state, ...countdownTimer.getState()})}></button>\n          <button className=\"App-button-stop\" onMouseDown={() => countdownTimer.stop() && setState({...state, ...countdownTimer.getState()})}></button>\n          <button className=\"App-button-lap\" onMouseDown={() => countdownTimer.lap() && setState({...state, ...countdownTimer.getState()})}></button>\n          <button className=\"App-button-clear\" onMouseDown={() => countdownTimer.clear() && setState({...state, ...countdownTimer.getState()})}></button>\n        </nav>\n      </main>\n      {/*\n      <div>\n        <pre>\n          state: {serialize(state, null, 2)}\n        </pre>\n        <pre>\n          laps: {serialize(laps, null, 2)}\n        </pre>\n      </div>\n      */}\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://cra.link/PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(/^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/)\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://cra.link/PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://cra.link/PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log('No internet connection found. App is running in offline mode.');\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then((registration) => {\n        registration.unregister();\n      })\n      .catch((error) => {\n        console.error(error.message);\n      });\n  }\n}\n","const reportWebVitals = (onPerfEntry) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorkerRegistration from './serviceWorkerRegistration';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://cra.link/PWA\nserviceWorkerRegistration.unregister();\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}